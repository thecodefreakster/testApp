{"version":3,"sources":["../index.ts","../../core/test/mock-embedding-model-v1.ts","../../core/test/mock-id.ts","../../core/test/mock-language-model-v1.ts","../../core/test/mock-values.ts"],"sourcesContent":["export { convertArrayToReadableStream } from '@ai-sdk/provider-utils/test';\nexport { MockEmbeddingModelV1 } from '../core/test/mock-embedding-model-v1';\nexport { mockId } from '../core/test/mock-id';\nexport { MockLanguageModelV1 } from '../core/test/mock-language-model-v1';\nexport { mockValues } from '../core/test/mock-values';\n","import { EmbeddingModelV1 } from '@ai-sdk/provider';\nimport { Embedding } from '../types';\nimport { EmbeddingModelUsage } from '../types/usage';\n\nexport class MockEmbeddingModelV1<VALUE> implements EmbeddingModelV1<VALUE> {\n  readonly specificationVersion = 'v1';\n\n  readonly provider: EmbeddingModelV1<VALUE>['provider'];\n  readonly modelId: EmbeddingModelV1<VALUE>['modelId'];\n  readonly maxEmbeddingsPerCall: EmbeddingModelV1<VALUE>['maxEmbeddingsPerCall'];\n  readonly supportsParallelCalls: EmbeddingModelV1<VALUE>['supportsParallelCalls'];\n\n  doEmbed: EmbeddingModelV1<VALUE>['doEmbed'];\n\n  constructor({\n    provider = 'mock-provider',\n    modelId = 'mock-model-id',\n    maxEmbeddingsPerCall = 1,\n    supportsParallelCalls = false,\n    doEmbed = notImplemented,\n  }: {\n    provider?: EmbeddingModelV1<VALUE>['provider'];\n    modelId?: EmbeddingModelV1<VALUE>['modelId'];\n    maxEmbeddingsPerCall?:\n      | EmbeddingModelV1<VALUE>['maxEmbeddingsPerCall']\n      | null;\n    supportsParallelCalls?: EmbeddingModelV1<VALUE>['supportsParallelCalls'];\n    doEmbed?: EmbeddingModelV1<VALUE>['doEmbed'];\n  } = {}) {\n    this.provider = provider;\n    this.modelId = modelId;\n    this.maxEmbeddingsPerCall = maxEmbeddingsPerCall ?? undefined;\n    this.supportsParallelCalls = supportsParallelCalls;\n    this.doEmbed = doEmbed;\n  }\n}\n\nexport function mockEmbed<VALUE>(\n  expectedValues: Array<VALUE>,\n  embeddings: Array<Embedding>,\n  usage?: EmbeddingModelUsage,\n): EmbeddingModelV1<VALUE>['doEmbed'] {\n  return async ({ values }) => {\n    assert.deepStrictEqual(expectedValues, values);\n    return { embeddings, usage };\n  };\n}\n\nfunction notImplemented(): never {\n  throw new Error('Not implemented');\n}\n","export function mockId(): () => string {\n  let counter = 0;\n  return () => `id-${counter++}`;\n}\n","import { LanguageModelV1 } from '@ai-sdk/provider';\n\nexport class MockLanguageModelV1 implements LanguageModelV1 {\n  readonly specificationVersion = 'v1';\n\n  readonly provider: LanguageModelV1['provider'];\n  readonly modelId: LanguageModelV1['modelId'];\n\n  supportsUrl: LanguageModelV1['supportsUrl'];\n  doGenerate: LanguageModelV1['doGenerate'];\n  doStream: LanguageModelV1['doStream'];\n\n  readonly defaultObjectGenerationMode: LanguageModelV1['defaultObjectGenerationMode'];\n  readonly supportsStructuredOutputs: LanguageModelV1['supportsStructuredOutputs'];\n  constructor({\n    provider = 'mock-provider',\n    modelId = 'mock-model-id',\n    supportsUrl = undefined,\n    doGenerate = notImplemented,\n    doStream = notImplemented,\n    defaultObjectGenerationMode = undefined,\n    supportsStructuredOutputs = undefined,\n  }: {\n    provider?: LanguageModelV1['provider'];\n    modelId?: LanguageModelV1['modelId'];\n    supportsUrl?: LanguageModelV1['supportsUrl'];\n    doGenerate?: LanguageModelV1['doGenerate'];\n    doStream?: LanguageModelV1['doStream'];\n    defaultObjectGenerationMode?: LanguageModelV1['defaultObjectGenerationMode'];\n    supportsStructuredOutputs?: LanguageModelV1['supportsStructuredOutputs'];\n  } = {}) {\n    this.provider = provider;\n    this.modelId = modelId;\n    this.doGenerate = doGenerate;\n    this.doStream = doStream;\n    this.supportsUrl = supportsUrl;\n\n    this.defaultObjectGenerationMode = defaultObjectGenerationMode;\n    this.supportsStructuredOutputs = supportsStructuredOutputs;\n  }\n}\n\nfunction notImplemented(): never {\n  throw new Error('Not implemented');\n}\n","export function mockValues<T>(...values: T[]): () => T {\n  let counter = 0;\n  return () => values[counter++] ?? values[values.length - 1];\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBAA6C;;;ACItC,IAAM,uBAAN,MAAqE;AAAA,EAU1E,YAAY;AAAA,IACV,WAAW;AAAA,IACX,UAAU;AAAA,IACV,uBAAuB;AAAA,IACvB,wBAAwB;AAAA,IACxB,UAAU;AAAA,EACZ,IAQI,CAAC,GAAG;AAvBR,SAAS,uBAAuB;AAwB9B,SAAK,WAAW;AAChB,SAAK,UAAU;AACf,SAAK,uBAAuB,sDAAwB;AACpD,SAAK,wBAAwB;AAC7B,SAAK,UAAU;AAAA,EACjB;AACF;AAaA,SAAS,iBAAwB;AAC/B,QAAM,IAAI,MAAM,iBAAiB;AACnC;;;AClDO,SAAS,SAAuB;AACrC,MAAI,UAAU;AACd,SAAO,MAAM,MAAM,SAAS;AAC9B;;;ACDO,IAAM,sBAAN,MAAqD;AAAA,EAY1D,YAAY;AAAA,IACV,WAAW;AAAA,IACX,UAAU;AAAA,IACV,cAAc;AAAA,IACd,aAAaA;AAAA,IACb,WAAWA;AAAA,IACX,8BAA8B;AAAA,IAC9B,4BAA4B;AAAA,EAC9B,IAQI,CAAC,GAAG;AA3BR,SAAS,uBAAuB;AA4B9B,SAAK,WAAW;AAChB,SAAK,UAAU;AACf,SAAK,aAAa;AAClB,SAAK,WAAW;AAChB,SAAK,cAAc;AAEnB,SAAK,8BAA8B;AACnC,SAAK,4BAA4B;AAAA,EACnC;AACF;AAEA,SAASA,kBAAwB;AAC/B,QAAM,IAAI,MAAM,iBAAiB;AACnC;;;AC5CO,SAAS,cAAiB,QAAsB;AACrD,MAAI,UAAU;AACd,SAAO,MAAG;AAFZ;AAEe,wBAAO,SAAS,MAAhB,YAAqB,OAAO,OAAO,SAAS,CAAC;AAAA;AAC5D;","names":["notImplemented"]}